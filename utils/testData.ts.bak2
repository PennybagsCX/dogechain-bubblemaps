/**
 * Mock Test Data Generator for Alert System Testing
 *
 * This file provides utility functions to generate test alerts and triggered events
 * for testing the embedded Dexscreener chart integration.
 *
 * USAGE:
 * 1. Import this file in your development environment
 * 2. Call generateMockTestAlerts() to populate IndexedDB with test data
 * 3. Refresh the Dashboard to see charts
 */

import { db, toDbAlert, toDbTriggeredEvent } from "../services/db";
import type { AlertConfig, TriggeredEvent } from "../types";

/**
 * Mock test alerts with real Dogechain token addresses
 */
export const MOCK_TEST_ALERTS: AlertConfig[] = [
  {
    id: "test-wdoge-001",
    name: "wDOGE Test Alert",
    walletAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    tokenAddress: "0xb7ddc6414bf4f5515b52d8bdd69973ae205ff101",
    tokenSymbol: "wDOGE",
    tokenName: "Wrapped Doge",
    threshold: 5000000000,
    initialValue: 10000000000,
  },
  {
    id: "test-doge-002",
    name: "DOGE Liquidity Pool Alert",
    walletAddress: "0x3525ed5f48eb3a3a0442dbb72a5ee48f749f7b07",
    tokenAddress: "0xb7ddc6414bf4f5515b52d8bdd69973ae205ff101",
    tokenSymbol: "wDOGE",
    tokenName: "Wrapped Doge",
    threshold: 10000000000,
    initialValue: 50000000000,
  },
  {
    id: "test-eth-003",
    name: "wETH Test Alert",
    walletAddress: "0x73b5298c6c1a31b29b2234ab19d3a4a5a0810149",
    tokenAddress: "0xb65043c45b24122b0b7984ffed87fd7bcf9fdf68",
    tokenSymbol: "wETH",
    tokenName: "Wrapped Ethereum",
    threshold: 1000000000000000000, // 1 wETH
    initialValue: 5000000000000000000, // 5 wETH
  },
  {
    id: "test-usdt-004",
    name: "USDT Test Alert",
    walletAddress: "0x64c516a6eaa8b8fc4d6b0b5e5b5e5e5e5e5e5e5e",
    tokenAddress: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    tokenSymbol: "USDT",
    tokenName: "Tether USD",
    threshold: 1000000000, // 1000 USDT (6 decimals)
    initialValue: 10000000000, // 10000 USDT
  },
  {
    id: "test-usdc-005",
    name: "USDC Test Alert",
    walletAddress: "0x6c13963e0d30f4a1cf4c8cff4a9afc35cf6f7d87",
    tokenAddress: "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
    tokenSymbol: "USDC",
    tokenName: "USD Coin",
    threshold: 1000000000, // 1000 USDC (6 decimals)
    initialValue: 10000000000, // 10000 USDC
  },
];

/**
 * Mock triggered events for testing notification display
 */
export const MOCK_TRIGGERED_EVENTS: TriggeredEvent[] = [
  {
    id: "event-test-001",
    alertId: "test-wdoge-001",
    alertName: "wDOGE Test Alert",
    walletAddress: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    tokenAddress: "0xb7ddc6414bf4f5515b52d8bdd69973ae205ff101",
    tokenSymbol: "wDOGE",
    transactions: [
      {
        hash: "0x" + "1".repeat(64),
        from: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
        to: "0x0000000000000000000000000000000000000000",
        value: 1_000_000_000_000_000_000,
        timestamp: Date.now() - 3600000,
      },
    ],
    triggeredAt: Date.now() - 3600000,
    notified: false,
  },
];

/**
 * Clear all test alerts from the database
 */
export async function clearTestAlerts(): Promise<void> {
  try {
    // Get all test alerts (IDs starting with "test-")
    const allAlerts = await db.alerts.toArray();
    const testAlerts = allAlerts.filter((alert) => alert.alertId.startsWith("test-"));

    // Delete test alerts
    for (const alert of testAlerts) {
      await db.alerts.delete(alert.id!);
      await db.alertStatuses.delete(alert.alertId);
    }

    // Clear test triggered events
    const allEvents = await db.triggeredEvents.toArray();
    const testEvents = allEvents.filter((event) => event.eventId.startsWith("event-test-"));

    for (const event of testEvents) {
      await db.triggeredEvents.delete(event.id!);
    }

    console.log(
      `[TestData] Cleared ${testAlerts.length} test alerts and ${testEvents.length} test events`
    );
  } catch (error) {

  }
}

/**
 * Generate mock test alerts in IndexedDB
 * This populates the database with test data for chart testing
 */
export async function generateMockTestAlerts(): Promise<void> {
  try {


    // Clear existing test data first
    await clearTestAlerts();

    // Add test alerts
    for (const alertConfig of MOCK_TEST_ALERTS) {
      const dbAlert = toDbAlert(alertConfig);
      await db.alerts.put(dbAlert);

      // Create alert status
      await db.alertStatuses.put({
        alertId: alertConfig.id,
        currentValue: alertConfig.initialValue || 0,
        triggered: false,
        checkedAt: Date.now(),
        notified: false,
        lastSeenTransactions: [],
      });

`);
    }

    // Add triggered events
    for (const event of MOCK_TRIGGERED_EVENTS) {
      const dbEvent = toDbTriggeredEvent(event);
      await db.triggeredEvents.put(dbEvent);

    }



  } catch (error) {

  }
}

/**
 * Browser console script for manual testing
 * Copy and paste this into the browser console to add test alerts
 */
export const BROWSER_CONSOLE_SCRIPT = `
(async () => {
  const DB_NAME = 'DogechainBubbleMapsDB';
  const DB_VERSION = 16;

  // Test alerts data
  const testAlerts = [
    {
      alertId: 'test-wdoge-001',
      name: 'wDOGE Test Alert',
      walletAddress: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
      tokenAddress: '0xb7ddc6414bf4f5515b52d8bdd69973ae205ff101',
      tokenSymbol: 'wDOGE',
      tokenName: 'Wrapped Doge',
      threshold: 5000000000,
      initialValue: 10000000000,
      createdAt: Date.now()
    },
    {
      alertId: 'test-doge-002',
      name: 'DOGE Bridge Pool Alert',
      walletAddress: '0x3525ed5f48eb3a3a0442dbb72a5ee48f749f7b07',
      tokenAddress: '0xb7ddc6414bf4f5515b52d8bdd69973ae205ff101',
      tokenSymbol: 'wDOGE',
      tokenName: 'Wrapped Doge',
      threshold: 10000000000,
      initialValue: 50000000000,
      createdAt: Date.now()
    },
    {
      alertId: 'test-eth-003',
      name: 'wETH Test Alert',
      walletAddress: '0x73b5298c6c1a31b29b2234ab19d3a4a5a0810149',
      tokenAddress: '0xb65043c45b24122b0b7984ffed87fd7bcf9fdf68',
      tokenSymbol: 'wETH',
      tokenName: 'Wrapped Ethereum',
      threshold: 1000000000000000000,
      initialValue: 5000000000000000000,
      createdAt: Date.now()
    }
  ];

  try {
    // Open database
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    const db = await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
      request.onblocked = () => reject(new Error("Database open request was blocked"));
    });

    // Create transaction
    const tx = db.transaction(['alerts', 'alertStatuses'], 'readwrite');
    const alertsStore = tx.objectStore('alerts');
    const statusesStore = tx.objectStore('alertStatuses');

    // Clear existing test alerts
    const existingAlerts = await new Promise((resolve, reject) => {
      const request = alertsStore.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });

    for (const alert of existingAlerts) {
      if (alert.alertId.startsWith('test-')) {
        alertsStore.delete(alert.id);
        statusesStore.delete(alert.alertId);
      }
    }

    // Add test alerts
    for (const alert of testAlerts) {
      // Add alert
      await new Promise((resolve, reject) => {
        const request = alertsStore.put(alert);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });

      // Add alert status
      await new Promise((resolve, reject) => {
        const request = statusesStore.put({
          alertId: alert.alertId,
          currentValue: alert.initialValue || 0,
          triggered: false,
          checkedAt: Date.now(),
          notified: false,
          lastSeenTransactions: []
        });
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });

    }

    await new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });

    db.close();




  } catch (error) {

  }
})();
`;

/**
 * Print the browser console script to stdout for easy copying
 */
export function printBrowserConsoleScript(): void {
}
